package scala.reflect.persistence

import scala.language.postfixOps
import java.nio.ByteBuffer
import java.io.DataOutputStream
import scala.annotation.tailrec

class LzwCompressor(out: DataOutputStream) {
  /* TODO: the idea here is to use one instance of this compressor to compress everything
   * that does not require a tree compression. Instead of taking a string as argument, we
   * could imagine having one extension of the LzwCompressor for each separate lists
   * generated by the TreeDecomposer, more specialized. For instance, the bit indicating
   * that a name is a TermName does not require to be encoded fully as a Char in the
   * string (8 bits). We could save storage by using only one bit. Follows of course the
   * problem of the alignment of values - the next Name's name will remain a string. */
  /* TODO: see if want the decompression implemented on the same class or not */
  /* TODO: see if ASCII is enough */
  /* TODO: see if we want this kind of output */
  val initialSize = 256 /* Initial size of the dictionary (ASCII) */

  var dict = List range (0, initialSize) map (x => (List(x.toChar) -> x.toShort)) toMap
  var buffer: List[Char] = List()

  private def shortToArray(x: Short) = ByteBuffer.allocate(2).putShort(x).array()

  def apply(in: String): Unit = {
    @tailrec def loop(src: List[Char]): Unit = src match {
      case x :: xs if dict contains (buffer :+ x) =>
        buffer :+= x
        loop(xs)
      case x :: xs =>
        out.write(shortToArray(dict.get(buffer).get))
        dict += ((buffer :+ x) -> (dict.size + 1).toShort)
        buffer = x :: Nil
        loop(xs)
      case Nil => /* Nothing more for this round */
    }
    loop(in.toCharArray.toList)
  }

  def flush = if (!buffer.isEmpty) out.write(shortToArray(dict.get(buffer).get)) /* Print the leftover */
}
